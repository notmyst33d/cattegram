// This is a file generated by cattlc, do not modify unless you know what you are doing.

use crate::tl_object::TlObject;
use crate::bytes_buffer::BytesBuffer;

#[derive(Debug, Default)]
pub struct resPQ {
pub hash: u32,
pub nonce: u128,
pub server_nonce: u128,
pub pq: &'static [u8],
pub server_public_key_fingerprints: Vec<u64>,
}
impl TlObject for resPQ {
    fn hash(&self) -> u32 {
        self.hash
    }
}
pub fn read_resPQ(data: &mut BytesBuffer) -> Option<Box<dyn TlObject>> {
let mut obj = resPQ::default();
obj.hash = 0x5162463;
obj.nonce = data.read_u128();
obj.server_nonce = data.read_u128();
obj.pq = data.read_bytes();
obj.server_public_key_fingerprints = {
    let mut vector_data = vec![];
    let vector_header = data.read_u32();
    let mut length = 0;
    if vector_header == 0x1cb5c415 {
        length = data.read_u32();
    } else {
        length = vector_header;
    }

    for _ in 0..length {
        let value = data.read_u64();
        vector_data.push(value);
    }

    vector_data
};
Some(Box::new(obj))
}

#[derive(Debug, Default)]
pub struct req_pq_multi {
pub hash: u32,
pub nonce: u128,
}
impl TlObject for req_pq_multi {
    fn hash(&self) -> u32 {
        self.hash
    }
}
pub fn read_req_pq_multi(data: &mut BytesBuffer) -> Option<Box<dyn TlObject>> {
let mut obj = req_pq_multi::default();
obj.hash = 0xbe7e8ef1;
obj.nonce = data.read_u128();
Some(Box::new(obj))
}

