// This is a file generated by cattlc, do not modify unless you know what you are doing.

use crate::{TlObject, TlError, TlReader, BytesBuffer};
#[allow(non_camel_case_types)]
#[derive(Debug, Default)]
pub struct resPQ {
pub nonce: i128,
pub server_nonce: i128,
pub pq: &'static [u8],
pub server_public_key_fingerprints: Vec<i64>,
}
impl TlObject for resPQ {
    fn hash(&self) -> i32 {
        85337187
    }
    fn write(&self, data: &mut BytesBuffer) {
        data.write_int(85337187);
data.write_int128(self.nonce);
data.write_int128(self.server_nonce);
data.write_bytes(self.pq);
{
    data.write_int(0x1cb5c415);
    data.write_int(self.server_public_key_fingerprints.len() as i32);
    for element in &self.server_public_key_fingerprints {
        data.write_long(*element);
    }
};

    }
}
#[allow(non_snake_case)]
pub fn read_resPQ(data: &mut BytesBuffer) -> Result<resPQ, TlError> {
let mut obj = resPQ::default();
obj.nonce = data.read_int128()?;
obj.server_nonce = data.read_int128()?;
obj.pq = data.read_bytes()?;
obj.server_public_key_fingerprints = {
    let mut vector_data = vec![];
    let vector_header = data.read_int()?;
    let length = if vector_header == 0x1cb5c415 {
        data.read_int()?
    } else {
        vector_header
    };

    for _ in 0..length {
        let value = data.read_long()?;
        vector_data.push(value);
    }

    vector_data
};
Ok(obj)
}


#[allow(non_camel_case_types)]
#[derive(Debug, Default)]
pub struct p_q_inner_data_dc {
pub pq: &'static [u8],
pub p: &'static [u8],
pub q: &'static [u8],
pub nonce: i128,
pub server_nonce: i128,
pub new_nonce: &'static [u8],
pub dc: i32,
}
impl TlObject for p_q_inner_data_dc {
    fn hash(&self) -> i32 {
        -1443537003
    }
    fn write(&self, data: &mut BytesBuffer) {
        data.write_int(-1443537003);
data.write_bytes(self.pq);
data.write_bytes(self.p);
data.write_bytes(self.q);
data.write_int128(self.nonce);
data.write_int128(self.server_nonce);
data.write_raw(self.new_nonce);
data.write_int(self.dc);

    }
}
#[allow(non_snake_case)]
pub fn read_p_q_inner_data_dc(data: &mut BytesBuffer) -> Result<p_q_inner_data_dc, TlError> {
let mut obj = p_q_inner_data_dc::default();
obj.pq = data.read_bytes()?;
obj.p = data.read_bytes()?;
obj.q = data.read_bytes()?;
obj.nonce = data.read_int128()?;
obj.server_nonce = data.read_int128()?;
obj.new_nonce = data.read_raw(32)?;
obj.dc = data.read_int()?;
Ok(obj)
}


#[allow(non_camel_case_types)]
#[derive(Debug, Default)]
pub struct p_q_inner_data_temp_dc {
pub pq: &'static [u8],
pub p: &'static [u8],
pub q: &'static [u8],
pub nonce: i128,
pub server_nonce: i128,
pub new_nonce: &'static [u8],
pub dc: i32,
pub expires_in: i32,
}
impl TlObject for p_q_inner_data_temp_dc {
    fn hash(&self) -> i32 {
        1459478408
    }
    fn write(&self, data: &mut BytesBuffer) {
        data.write_int(1459478408);
data.write_bytes(self.pq);
data.write_bytes(self.p);
data.write_bytes(self.q);
data.write_int128(self.nonce);
data.write_int128(self.server_nonce);
data.write_raw(self.new_nonce);
data.write_int(self.dc);
data.write_int(self.expires_in);

    }
}
#[allow(non_snake_case)]
pub fn read_p_q_inner_data_temp_dc(data: &mut BytesBuffer) -> Result<p_q_inner_data_temp_dc, TlError> {
let mut obj = p_q_inner_data_temp_dc::default();
obj.pq = data.read_bytes()?;
obj.p = data.read_bytes()?;
obj.q = data.read_bytes()?;
obj.nonce = data.read_int128()?;
obj.server_nonce = data.read_int128()?;
obj.new_nonce = data.read_raw(32)?;
obj.dc = data.read_int()?;
obj.expires_in = data.read_int()?;
Ok(obj)
}


#[allow(non_camel_case_types)]
#[derive(Debug, Default)]
pub struct server_DH_params_ok {
pub nonce: i128,
pub server_nonce: i128,
pub encrypted_answer: &'static [u8],
}
impl TlObject for server_DH_params_ok {
    fn hash(&self) -> i32 {
        -790100132
    }
    fn write(&self, data: &mut BytesBuffer) {
        data.write_int(-790100132);
data.write_int128(self.nonce);
data.write_int128(self.server_nonce);
data.write_bytes(self.encrypted_answer);

    }
}
#[allow(non_snake_case)]
pub fn read_server_DH_params_ok(data: &mut BytesBuffer) -> Result<server_DH_params_ok, TlError> {
let mut obj = server_DH_params_ok::default();
obj.nonce = data.read_int128()?;
obj.server_nonce = data.read_int128()?;
obj.encrypted_answer = data.read_bytes()?;
Ok(obj)
}


#[allow(non_camel_case_types)]
#[derive(Debug, Default)]
pub struct server_DH_inner_data {
pub nonce: i128,
pub server_nonce: i128,
pub g: i32,
pub dh_prime: &'static [u8],
pub g_a: &'static [u8],
pub server_time: i32,
}
impl TlObject for server_DH_inner_data {
    fn hash(&self) -> i32 {
        -1249309254
    }
    fn write(&self, data: &mut BytesBuffer) {
        data.write_int(-1249309254);
data.write_int128(self.nonce);
data.write_int128(self.server_nonce);
data.write_int(self.g);
data.write_bytes(self.dh_prime);
data.write_bytes(self.g_a);
data.write_int(self.server_time);

    }
}
#[allow(non_snake_case)]
pub fn read_server_DH_inner_data(data: &mut BytesBuffer) -> Result<server_DH_inner_data, TlError> {
let mut obj = server_DH_inner_data::default();
obj.nonce = data.read_int128()?;
obj.server_nonce = data.read_int128()?;
obj.g = data.read_int()?;
obj.dh_prime = data.read_bytes()?;
obj.g_a = data.read_bytes()?;
obj.server_time = data.read_int()?;
Ok(obj)
}


#[allow(non_camel_case_types)]
#[derive(Debug, Default)]
pub struct client_DH_inner_data {
pub nonce: i128,
pub server_nonce: i128,
pub retry_id: i64,
pub g_b: &'static [u8],
}
impl TlObject for client_DH_inner_data {
    fn hash(&self) -> i32 {
        1715713620
    }
    fn write(&self, data: &mut BytesBuffer) {
        data.write_int(1715713620);
data.write_int128(self.nonce);
data.write_int128(self.server_nonce);
data.write_long(self.retry_id);
data.write_bytes(self.g_b);

    }
}
#[allow(non_snake_case)]
pub fn read_client_DH_inner_data(data: &mut BytesBuffer) -> Result<client_DH_inner_data, TlError> {
let mut obj = client_DH_inner_data::default();
obj.nonce = data.read_int128()?;
obj.server_nonce = data.read_int128()?;
obj.retry_id = data.read_long()?;
obj.g_b = data.read_bytes()?;
Ok(obj)
}


#[allow(non_camel_case_types)]
#[derive(Debug, Default)]
pub struct dh_gen_ok {
pub nonce: i128,
pub server_nonce: i128,
pub new_nonce_hash1: i128,
}
impl TlObject for dh_gen_ok {
    fn hash(&self) -> i32 {
        1003222836
    }
    fn write(&self, data: &mut BytesBuffer) {
        data.write_int(1003222836);
data.write_int128(self.nonce);
data.write_int128(self.server_nonce);
data.write_int128(self.new_nonce_hash1);

    }
}
#[allow(non_snake_case)]
pub fn read_dh_gen_ok(data: &mut BytesBuffer) -> Result<dh_gen_ok, TlError> {
let mut obj = dh_gen_ok::default();
obj.nonce = data.read_int128()?;
obj.server_nonce = data.read_int128()?;
obj.new_nonce_hash1 = data.read_int128()?;
Ok(obj)
}


#[allow(non_camel_case_types)]
#[derive(Debug, Default)]
pub struct dh_gen_retry {
pub nonce: i128,
pub server_nonce: i128,
pub new_nonce_hash2: i128,
}
impl TlObject for dh_gen_retry {
    fn hash(&self) -> i32 {
        1188831161
    }
    fn write(&self, data: &mut BytesBuffer) {
        data.write_int(1188831161);
data.write_int128(self.nonce);
data.write_int128(self.server_nonce);
data.write_int128(self.new_nonce_hash2);

    }
}
#[allow(non_snake_case)]
pub fn read_dh_gen_retry(data: &mut BytesBuffer) -> Result<dh_gen_retry, TlError> {
let mut obj = dh_gen_retry::default();
obj.nonce = data.read_int128()?;
obj.server_nonce = data.read_int128()?;
obj.new_nonce_hash2 = data.read_int128()?;
Ok(obj)
}


#[allow(non_camel_case_types)]
#[derive(Debug, Default)]
pub struct dh_gen_fail {
pub nonce: i128,
pub server_nonce: i128,
pub new_nonce_hash3: i128,
}
impl TlObject for dh_gen_fail {
    fn hash(&self) -> i32 {
        -1499615742
    }
    fn write(&self, data: &mut BytesBuffer) {
        data.write_int(-1499615742);
data.write_int128(self.nonce);
data.write_int128(self.server_nonce);
data.write_int128(self.new_nonce_hash3);

    }
}
#[allow(non_snake_case)]
pub fn read_dh_gen_fail(data: &mut BytesBuffer) -> Result<dh_gen_fail, TlError> {
let mut obj = dh_gen_fail::default();
obj.nonce = data.read_int128()?;
obj.server_nonce = data.read_int128()?;
obj.new_nonce_hash3 = data.read_int128()?;
Ok(obj)
}


#[allow(non_camel_case_types)]
#[derive(Debug, Default)]
pub struct req_pq_multi {
pub nonce: i128,
}
impl TlObject for req_pq_multi {
    fn hash(&self) -> i32 {
        -1099002127
    }
    fn write(&self, data: &mut BytesBuffer) {
        data.write_int(-1099002127);
data.write_int128(self.nonce);

    }
}
#[allow(non_snake_case)]
pub fn read_req_pq_multi(data: &mut BytesBuffer) -> Result<req_pq_multi, TlError> {
let mut obj = req_pq_multi::default();
obj.nonce = data.read_int128()?;
Ok(obj)
}


#[allow(non_camel_case_types)]
#[derive(Debug, Default)]
pub struct req_DH_params {
pub nonce: i128,
pub server_nonce: i128,
pub p: &'static [u8],
pub q: &'static [u8],
pub public_key_fingerprint: i64,
pub encrypted_data: &'static [u8],
}
impl TlObject for req_DH_params {
    fn hash(&self) -> i32 {
        -686627650
    }
    fn write(&self, data: &mut BytesBuffer) {
        data.write_int(-686627650);
data.write_int128(self.nonce);
data.write_int128(self.server_nonce);
data.write_bytes(self.p);
data.write_bytes(self.q);
data.write_long(self.public_key_fingerprint);
data.write_bytes(self.encrypted_data);

    }
}
#[allow(non_snake_case)]
pub fn read_req_DH_params(data: &mut BytesBuffer) -> Result<req_DH_params, TlError> {
let mut obj = req_DH_params::default();
obj.nonce = data.read_int128()?;
obj.server_nonce = data.read_int128()?;
obj.p = data.read_bytes()?;
obj.q = data.read_bytes()?;
obj.public_key_fingerprint = data.read_long()?;
obj.encrypted_data = data.read_bytes()?;
Ok(obj)
}


#[allow(non_camel_case_types)]
#[derive(Debug, Default)]
pub struct set_client_DH_params {
pub nonce: i128,
pub server_nonce: i128,
pub encrypted_data: &'static [u8],
}
impl TlObject for set_client_DH_params {
    fn hash(&self) -> i32 {
        -184262881
    }
    fn write(&self, data: &mut BytesBuffer) {
        data.write_int(-184262881);
data.write_int128(self.nonce);
data.write_int128(self.server_nonce);
data.write_bytes(self.encrypted_data);

    }
}
#[allow(non_snake_case)]
pub fn read_set_client_DH_params(data: &mut BytesBuffer) -> Result<set_client_DH_params, TlError> {
let mut obj = set_client_DH_params::default();
obj.nonce = data.read_int128()?;
obj.server_nonce = data.read_int128()?;
obj.encrypted_data = data.read_bytes()?;
Ok(obj)
}


pub fn extend_reader(reader: &mut TlReader) {
reader.add_reader(85337187, |data| read_resPQ(data).map(|o| Box::new(o) as Box<dyn TlObject>));
reader.add_reader(-1443537003, |data| read_p_q_inner_data_dc(data).map(|o| Box::new(o) as Box<dyn TlObject>));
reader.add_reader(1459478408, |data| read_p_q_inner_data_temp_dc(data).map(|o| Box::new(o) as Box<dyn TlObject>));
reader.add_reader(-790100132, |data| read_server_DH_params_ok(data).map(|o| Box::new(o) as Box<dyn TlObject>));
reader.add_reader(-1249309254, |data| read_server_DH_inner_data(data).map(|o| Box::new(o) as Box<dyn TlObject>));
reader.add_reader(1715713620, |data| read_client_DH_inner_data(data).map(|o| Box::new(o) as Box<dyn TlObject>));
reader.add_reader(1003222836, |data| read_dh_gen_ok(data).map(|o| Box::new(o) as Box<dyn TlObject>));
reader.add_reader(1188831161, |data| read_dh_gen_retry(data).map(|o| Box::new(o) as Box<dyn TlObject>));
reader.add_reader(-1499615742, |data| read_dh_gen_fail(data).map(|o| Box::new(o) as Box<dyn TlObject>));
reader.add_reader(-1099002127, |data| read_req_pq_multi(data).map(|o| Box::new(o) as Box<dyn TlObject>));
reader.add_reader(-686627650, |data| read_req_DH_params(data).map(|o| Box::new(o) as Box<dyn TlObject>));
reader.add_reader(-184262881, |data| read_set_client_DH_params(data).map(|o| Box::new(o) as Box<dyn TlObject>));
}
